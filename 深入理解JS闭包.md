### 深入理解JS闭包（closure）  
##### 目录&步骤  
1. [变量的作用域](#1)    
2. [如何从函数外部读取局部变量](#2)  
3. [闭包的概念](#3)  
4. [闭包的用途](#4)  
5. [使用闭包的注意点](#5)  
6. [JavaScript的垃圾回收机制](#6)  
    
---
<p id = "1"><b>一、变量的作用域</b></p>    
要理解闭包，必须先理解JS特殊的变量作用域：**全局变量和局部变量**  
1. 函数内部可以直接读取全局变量。代码示例：  
`var n = 999;`  
`function f1() {`  
——`alert(n);`  
`}`  
`f1();//999`  
2. 函数外部无法读取函数内部的局部变量。代码示例：  
`function f1() {`  
——`var n = 999;`  
`}`  
`alert(n);//error`  
**注：函数内部声明的时候，一定要使用var命令。如果不用的话，那么实际上声明了一个全局变量！**代码示例：  
`function f1() {`  
——`n = 999;`  
`}`  
`f1();`  
`alert(n);//999`  

---
<p id = "2"><b>二、如何从函数外部读取局部变量？</b></p>  
当需要得到函数内的局部变量时，只有通过变通方法才可实现：**在函数内部，再定义一个函数。**代码示例：  
`function f1() {`  
——`n = 999;`  
——`function f2() {`  
————`alert(n);//999`  
——`}`  
`}`  
解释：  
* 函数f2在函数f1内部，这时f1内部的所有局部变量，对f2来说都是可见的。  
* 但相反，f2内部的局部变量，对f1来说是不可见的。这就是JS语言特有的<b>“链式作用域”</b>结构（chain scope）。  
* 所以只要把f2作为返回值，便可以利用f2来读取f1中的局部变量。代码示例：  
`function f1() {`  
——`n = 999;`  
——`function f2() {`  
————`alert(n);`  
——`}`  
————`return f2`  
`}`  
`var result = f1();`  
`result();//999`  
解释：  
* 执行`var result = f1();`后，变量result实际上是指向了函数f2，再执行result()后就会弹出一个窗口显示n的值。  
* 这段代码就创建了一个闭包，因为函数f1外的变量result引用了函数f1内的函数f2。即：当函数f1的内部函数f2被函数f1外的一个变量引用的时候，就创建了一个闭包。  

---
<p id = "3"><b>三、闭包的概念</b></p>    
概念：
* 闭包是包含自由（未绑定到特定对象）变量的代码块；这些变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义（局部变量）。  
* 简单理解为：闭包是可以读取其他函数内部变量的函数，是定义在一个函数内部的函数。闭包是将函数内部和函数外部连接起来的桥梁。  
* 楼上的函数f2便是一个闭包。  

---
<p id = "4"><b>四、闭包的用途</b></p>  
典型的两个用处：  
* 读取函数内部的变量；  
* 让这些局部变量的值始终保持在内存中。代码示例：  
`function f1() {`  
——`var n = 999;`  
——`nAdd = function() { n += 1 }`  
——`function f2() {`  
————`alert(n);`  
——`}`  
——`return f2;`  
`}`  
`var result = f1();`  
`result();//999`  
`nAdd();`  
`result();//1000`  
解释：  
* result实际上是闭包f2函数，一共运行了2次，第一次的值是999，第二次是1000.这就证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。  
* 原因：f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中。而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用后被垃圾回收机制（garbage collection）回收。    
* `nAdd = function() { n += 1 }`的代码，nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而且nAdd的值是一个匿名函数，这个匿名函数本事也是一个闭包，可以在函数外部对函数内部的变量进行操作。  

---
<p id = "5"><b>五、使用闭包的注意点</b></p>   
* 不能滥用闭包，因为闭包会使得函数中的变量都被保存在内存中，内存消耗很大，会造成网页的性能问题（内存泄露）。解决方法：在退出函数之前，将不使用的局部变量全部删除。  
* 闭包会在父函数外部，改变父函数内部变量的值。因此不要随便改变父函数内部变量的值。  

---
<p id = "6"><b>JavaScript的垃圾回收机制</b></p>  
* 在JS中，如果一个对象不再被引用，那么这个对象就会被GC回收。如果两个对象相互引用，而不再被第三者引用，那么这两个相互引用的对象也会被回收。  

---
--End--



